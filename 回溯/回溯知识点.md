递归-----回溯（暴力搜索）说白了是解决不能for循环的列举问题

什么情况适合使用递归：

![image-20240621172720765](https://s2.loli.net/2024/06/21/ENvz3Dh2WCxJkHZ.png)

![image-20240621172804594](https://s2.loli.net/2024/06/21/n3jTELxJkYFqzZX.png)

![image-20240621173036175](https://s2.loli.net/2024/06/21/fRMYndbFBxhvt2K.png)

全局数组 path来记录递归路径中枚举的字母

🌟**注意：**dfs里面的递归参数中的 i 的含义不是第ⅰ个，而是(下标)大于等于i的这部分





**之所以称之为回溯算法，是因为该算法在搜索解空间时会采用“尝试”与“回退”的策略**。当算法在搜索过程中遇到某个状态无法继续前进或无法得到满足条件的解时，它会撤销上一步的选择，退回到之前的状态，并尝试其他可能的选择。

![回溯算法理论基础](https://code-thinking-1253855093.file.myqcloud.com/pics/20210130173631174.png)

例如：给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。

示例: 输入: n = 4, k = 2 输出: [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4] ] 

![77.组合1](https://code-thinking-1253855093.file.myqcloud.com/pics/20201123195242899.png)

回溯三部曲：

- 回溯函数模板返回值以及参数

- 回溯函数终止条件

- 回溯搜索的遍历过程

回溯法模板：

```
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

for循环就是遍历集合区间，可以理解**一个节点有多少个孩子，这个for循环就执行多少次**。





```go
tmp := make([]string, len(path))
			copy(tmp, path)
			ans = append(ans, tmp)
和
ans = append(ans, path)
的区别是什么？

```

### `tmp := make([]string, len(path)); `

### `copy(tmp, path); `

### `ans = append(ans, tmp)`

这一系列操作执行了一个**深拷贝**过程：

1. **创建新的切片 `tmp`**：使用 `make([]string, len(path))` 创建一个新的字符串切片，长度与 `path` 相同。
2. **复制内容**：`copy(tmp, path)` 将 `path` 切片中的所有元素复制到新的切片 `tmp` 中。这步操作是元素级别的复制，即使 `path` 后续被修改，`tmp` 中的元素也不会受到影响。
3. **将 `tmp` 添加到 `ans`**：此时添加的是 `tmp` 的一个引用，但由于 `tmp` 是 `path` 的一个完整复制，所以 `tmp` 与 `path` 是完全独立的。

这种方法在你需要保存 `path` 当前状态的副本时非常有用，确保 `ans` 中存储的是 `path` 的一个独立快照，不**会因为 `path` 在后续操作中的修改而改变**。

[^]: 当进行一个**深拷贝**操作时（如上文中所示，通过创建一个新的切片 `tmp` 并使用 `copy` 函数从 `path` 中复制元素），`tmp` 切片会拥有与 `path` 相同的元素，但它们存储在不同的内存地址中。因此，`tmp` 与 `path` 之间不共享内存。这样，即使在之后的程序中对 `path` 进行了修改（比如添加或删除元素，或者改变其中的元素的值），这些修改都不会影响到 `tmp` 中的数据。



### `ans = append(ans, path)`

这行代码执行了一个**浅拷贝**过程：

1. **直接添加 `path` 的引用**：这里没有创建 `path` 的一个新副本，而是直接将其引用（地址）添加到了 `ans` 中。
2. **`path` 修改的影响**：由于添加的是引用，如果后续对 `path` 的修改（如添加、删除元素或更改元素的值），所有这些修改都会反映在 `ans` 中已存储的相应 `path` 引用上。

在使用浅拷贝的情况下，如果你在追加 `path` 到 `ans` 后继续改变 `path` 的内容，这些更改将影响到 `ans` 中的相应数据。这在某些情况下可能导致错误或不预期的结果，特别是在需要保留历史数据状态的场景中。
