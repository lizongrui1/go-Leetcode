递归-----回溯（暴力搜索）说白了是解决不能for循环的列举问题

什么情况适合使用递归：

![image-20240621172720765](https://s2.loli.net/2024/06/21/ENvz3Dh2WCxJkHZ.png)

![image-20240621172804594](https://s2.loli.net/2024/06/21/n3jTELxJkYFqzZX.png)

![image-20240621173036175](https://s2.loli.net/2024/06/21/fRMYndbFBxhvt2K.png)

全局数组 path来记录递归路径中枚举的字母

🌟**注意：**dfs里面的递归参数中的 i 的含义不是第ⅰ个，而是(下标)大于等于i的这部分





**之所以称之为回溯算法，是因为该算法在搜索解空间时会采用“尝试”与“回退”的策略**。当算法在搜索过程中遇到某个状态无法继续前进或无法得到满足条件的解时，它会撤销上一步的选择，退回到之前的状态，并尝试其他可能的选择。

![回溯算法理论基础](https://code-thinking-1253855093.file.myqcloud.com/pics/20210130173631174.png)

例如：给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。

示例: 输入: n = 4, k = 2 输出: [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4] ] 

![77.组合1](https://code-thinking-1253855093.file.myqcloud.com/pics/20201123195242899.png)



回溯法模板：

```
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

for循环就是遍历集合区间，可以理解**一个节点有多少个孩子，这个for循环就执行多少次**。
