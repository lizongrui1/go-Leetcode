# 题目

给你一个 **无重复元素** 的整数数组 `candidates` 和一个目标整数 `target` ，找出 `candidates` 中可以使数字和为目标数 `target` 的 所有 **不同组合** ，并以列表形式返回。你可以按 **任意顺序** 返回这些组合。

`candidates` 中的 **同一个** 数字可以 **无限制重复被选取** 。如果至少一个数字的被选数量不同，则两种组合是不同的。 

对于给定的输入，保证和为 `target` 的不同组合数少于 `150` 个。

 

**示例 1：**

```
输入：candidates = [2,3,6,7], target = 7
输出：[[2,2,3],[7]]
解释：
2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。
7 也是一个候选， 7 = 7 。
仅有这两种组合。
```

**示例 2：**

```
输入: candidates = [2,3,5], target = 8
输出: [[2,2,2,2],[2,3,3],[3,5]]
```

**示例 3：**

```
输入: candidates = [2], target = 1
输出: []
```



# 提示





# 题解

我写的：

```go
func combinationSum(candidates []int, target int) [][]int {
	path := make([]int, 0)
	ans := make([][]int, 0)

	var dfs func(startIndex, sum int)
	dfs = func(startIndex, sum int) {
		if sum == target {
			ans = append(ans, append([]int(nil), path...))
			return
		}
		if sum > target { // 剪枝
			return
		}
		for i := startIndex; i < len(candidates); i++ {
			path = append(path, candidates[i])
			dfs(i, sum+candidates[i])
			path = path[:len(path)-1]

		}
	}
	dfs(0, 0)
	return ans
}
```

### 详细步骤

以下是候选数组为 `[2, 3, 5]`，目标和为 `8` 的详细递归过程：

1. **初始调用**：`dfs(0, 0)`，路径为空，当前总和为 `0`。

   ```
   dfs(0, 0) // 开始递归
   ```

2. **第一次递归**：

   - 从索引 0开始，尝试添加 2：

     ```
     path = [2], sum = 2
     dfs(0, 2) // 允许重复使用当前元素
     ```

3. **第二次递归**：

   - 从索引 0开始，再次添加 2：

     ```
     path = [2, 2], sum = 4
     dfs(0, 4) // 继续允许重复使用当前元素
     ```

4. **第三次递归**：

   - 从索引 0 开始，再次添加 2：

     ```
     path = [2, 2, 2], sum = 6
     dfs(0, 6) // 继续允许重复使用当前元素
     ```

5. **第四次递归**：

   - 从索引 0 开始，再次添加 2：

     ```
     path = [2, 2, 2, 2], sum = 8
     dfs(0, 8) // 总和达到目标值，添加到结果集
     ```

6. **回溯**：

   - 路径 [2, 2, 2, 2]被添加到结果集中后，回溯，移除最后一个元素，路径恢复为 [2, 2, 2]

     ```
     path = [2, 2, 2], sum = 6
     ```

7. **继续递归**：

   - 尝试添加其他元素：
     - 添加 `3` 会使总和超过 `8`，因此不继续递归。
     - 添加 `5` 同样会使总和超过 `8`。

8. **回溯**：

   - 再次回溯，路径恢复为 `[2, 2]`，继续尝试其他元素，直到所有组合被尝试完。
