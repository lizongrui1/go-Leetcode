# 题目

给你一个整数数组 `nums` 和一个整数 `k` ，请你统计并返回 *该数组中和为 `k` 的子数组的个数* 。

子数组是数组中元素的连续非空序列。



**示例 1：**

```
输入：nums = [1,1,1], k = 2
输出：2
```

**示例 2：**

```
输入：nums = [1,2,3], k = 3
输出：2
```

# 提示

1.子数组的定义要求其元素在原数组中的索引必须是连续的。子数组是数组中一段连续的非空序列。

这与子序列不同，子序列不要求其元素在原数组中的索引是连续的。

给定一个数组 `nums = [1, 2, 3, 4, 5]`：

- 连续子数组的例子：

  - `[1, 2]` （索引 0 到 1）

  - `[2, 3, 4]` （索引 1 到 3）

  - `[4, 5]` （索引 3 到 4）

  - `[1, 2, 3, 4, 5]` （索引 0 到 4）

    

  题目里面的子数组就是：

  ### 示例1：nums = [1,1,1], k = 2

  - 子数组 `[1,1]`（从索引`0`到`1`）的和是`1 + 1 = 2`。
  - 子数组 `[1,1]`（从索引`1`到`2`）的和是`1 + 1 = 2`。

  ### 示例2：nums = [1,2,3], k = 3

  - 子数组 `[1,2]`（从索引`0`到`1`）的和是`1 + 2 = 3`。
  - 子数组 `[3]`（索引`2`）的和是`3`。

子序列：子序列是从一个序列中删除一些元素（或不删除任何元素）后，不改变剩余元素相对顺序而得到的新序列。与子数组不同，子序列中的元素不要求在原数组中的索引是连续的。

假设我们有一个数组 `nums = [1, 2, 3]`：

- 子序列包括：
  - `[1]`
  - `[2]`
  - `[3]`
  - `[1, 2]`
  - `[1, 3]`
  - `[2, 3]`
  - `[1, 2, 3]`
  - `[]`（空子序列）

### 子序列与子数组的区别

- **子数组（Subarray）**：
  - 必须是数组中一段连续的元素序列。
  - 例如，对于数组 `[1, 2, 3, 4]`，合法的子数组包括 `[1, 2]`、`[2, 3, 4]` 等。
- **子序列（Subsequence）**：
  - 可以是不连续的，但元素的相对顺序不能改变。
  - 例如，对于数组 `[1, 2, 3, 4]`，合法的子序列包括 `[1, 3, 4]`、`[2, 4]` 等。



# 题解

1.暴力法：

```go
func subarraySum(nums []int, k int) int {
    count := 0
    for i := 0; i < len(nums); i++{
        sum := 0
        for j := i; j < len(nums); j++{     //从起始位置 i 开始，逐步增加子数组的长度，并计算子数组的和
            sum += nums[j]
            if sum == k{
                count++
            }
        }
    }
    return count
}
```



2.前缀和

```
func subarraySum(nums []int, k int) int {
	hash := make(map[int]int)
	hash[0] = 1		// 和为k的子数组的情况
	count := 0
	preSum := 0
	for i := 0; i < len(nums); i++ {
		preSum += nums[i]       // 计算当前前缀和
		if hash[preSum-k] > 0 { // 检查哈希表中是否存在 preSum - k
			count += hash[preSum-k] // 如果存在，则增加计数器
		}
		hash[preSum]++ // 更新哈希表中当前前缀和出现的次数
	}
	return count
}
```

