# 题目

有一堆石头，用整数数组 `stones` 表示。其中 `stones[i]` 表示第 `i` 块石头的重量。

每一回合，从中选出**任意两块石头**，然后将它们一起粉碎。假设石头的重量分别为 `x` 和 `y`，且 `x <= y`。那么粉碎的可能结果如下：

- 如果 `x == y`，那么两块石头都会被完全粉碎；
- 如果 `x != y`，那么重量为 `x` 的石头将会完全粉碎，而重量为 `y` 的石头新重量为 `y-x`。

最后，**最多只会剩下一块** 石头。返回此石头 **最小的可能重量** 。如果没有石头剩下，就返回 `0`。

 

**示例 1：**

```
输入：stones = [2,7,4,1,8,1]
输出：1
解释：
组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，
组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，
组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，
组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。
```

**示例 2：**

```
输入：stones = [31,26,33,21,40]
输出：5
```

**提示：**

- `1 <= stones.length <= 30`
- `1 <= stones[i] <= 100`

# 提示

本题其实就是尽量让石头分成重量相同的两堆，相撞之后剩下的石头最小，**这样就化解成01背包问题了**。



动规五步曲：

1. 确定dp数组以及下标的含义

**dp[j]表示容量（这里说容量更形象，其实就是重量）为j的背包，最多可以背最大重量为dp[j]**。

本题中，石头的重量是 stones[i]，石头的价值也是 stones[i] ，可以 “最多可以装的价值为 dp[j]” == “最多可以背的重量为dp[j]”

1. 确定递推公式

01背包的递推公式为：`dp[j] = max(dp[j], dp[j - weight[i]] + value[i])`

本题则是：`dp[j] = max(dp[j], dp[j - stones[i]] + stones[i])`

1. dp数组如何初始化





# 题解

```go
func lastStoneWeightII(stones []int) int {
	dp := make([]int, 15001)
	sum := 0
	for _, num := range stones {
		sum += num
	}
	target := sum / 2
	for i := range stones {
		for j := target; j >= stones[i]; j-- {
			dp[j] = max(dp[j], dp[j-stones[i]]+stones[i])
		}
	}
	return sum - 2*dp[target]
}
```

这里 `dp[target]` 是所有不超过 `target` 的子集中能达到的最大重量和。`sum - 2*dp[target]` 的计算基于以下逻辑：

- `sum` 是所有石头的总重量。
- `2*dp[target]` 是接近总重量一半的两组石头的总重量。
- 因此，`sum - 2*dp[target]` 就是两堆石头重量差的绝对值。

因为我们试图使一组石头的重量尽可能接近总重量的一半，所以 `sum - 2*dp[target]` 实际上就是在所有操作完成后可能剩下的石头的最小重量。这是因为一组石头的重量越接近总重量的一半，另一组自然也就越接近，从而最小化了最终的重量差。
