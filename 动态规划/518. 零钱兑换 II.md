# 题目

给你一个整数数组 `coins` 表示不同面额的硬币，另给一个整数 `amount` 表示总金额。

请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 `0` 。

假设每一种面额的硬币有无限个。 

题目数据保证结果符合 32 位带符号整数。

 

**示例 1：**

```
输入：amount = 5, coins = [1, 2, 5]
输出：4
解释：有四种方式可以凑成总金额：
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
```

**示例 2：**

```
输入：amount = 3, coins = [2]
输出：0
解释：只用面额 2 的硬币不能凑成总金额 3 。
```

**示例 3：**

```
输入：amount = 10, coins = [10] 
输出：1
```



# 提示

钱币数量不限:完全背包问题

本题是求**组合数**：一定要**先遍历物品后遍历背包**

**组合不强调元素之间的顺序，排列强调元素之间的顺序**。

动规五步曲：

1. 确定dp数组以及下标的含义

dp[j]：*凑成总金额 j 的货币组合数为dp[j]*

2.确定递推公式

`dp[j]` 就是所有的`dp[j - coins[i]]`（考虑`coins[i]`的情况）相加。

所以递推公式：`dp[j] += dp[j - coins[i]]`

> **求装满背包有几种方法，公式都是：`dp[j] += dp[j - nums[i]]`**

3. dp数组如何初始化

首先dp[0]一定要为1，dp[0] = 1是 递归公式的基础。如果dp[0] = 0 的话，后面所有推导出来的值都是0了。

4. 确定遍历顺序

本题是求凑出来的方案个数，且每个方案个数是为组合数。

**先遍历物品后遍历背包：**

```go
    for i := 0; i < len(coins); i++ {
        for j := coins[i]; j <= amount; j++ {
            dp[j] += dp[j-coins[i]]
        }
    }
```

假设：coins[0] = 1，coins[1] = 5。

那么就是先把1加入计算，然后再把5加入计算，得到的方法数量只有{1, 5}这种情况。而不会出现{5, 1}的情况。

**所以这种遍历顺序中dp[j]里计算的是组合数！**



**先遍历背包后遍历物品：**

```go
    for j := 0; j <= amount; j++ { // 遍历背包容量
        for i := 0; i < len(coins); i++ { // 遍历物品
            if j - coins[i] >= 0 {
                dp[j] += dp[j - coins[i]]
            }
        }
    }
```

背包容量的每一个值，都是经过 1 和 5 的计算，包含了{1, 5} 和 {5, 1}两种情况。

**此时dp[j]里算出来的就是排列数！**

51. 举例推导dp数组

![image-20240716204206006](C:/Users/zapu/AppData/Roaming/Typora/typora-user-images/image-20240716204206006.png)

# 题解

```go
func change(amount int, coins []int) int {
	dp := make([]int, amount+1) // dp[j] 表示总金额为 j 时的组合方式数量
	// 初始化,0大小的背包, 当然是不装任何东西了, 就是1种方法
	dp[0] = 1
	// 遍历顺序：先遍历物品后遍历背包
	for i := 0; i < len(coins); i++ {
		for j := coins[i]; j <= amount; j++ {
			dp[j] += dp[j-coins[i]]
		}
	}
	return dp[amount] // dp[amount]表示总金额为 amount 时的组合方式数量
}
```

