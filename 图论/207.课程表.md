# 题目

你这个学期必须选修 `numCourses` 门课程，记为 `0` 到 `numCourses - 1` 。

在选修某些课程之前需要一些先修课程。 先修课程按数组 `prerequisites` 给出，其中 `prerequisites[i] = [ai, bi]` ，表示如果要学习课程 `ai` 则 **必须** 先学习课程 `bi` 。

- 例如，先修课程对 `[0, 1]` 表示：想要学习课程 `0` ，你需要先完成课程 `1` 。

请你判断是否可能完成所有课程的学习？如果可以，返回 `true` ；否则，返回 `false` 。

 

**示例 1：**

```
输入：numCourses = 2, prerequisites = [[1,0]]
输出：true
解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。
```

**示例 2：**

```
输入：numCourses = 2, prerequisites = [[1,0],[0,1]]
输出：false
解释：总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。
```



# 提示

**拓扑排序**

序列必须满足下面两个条件：

1. 每个顶点出现且只出现一次。
2. 若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面。

有向无环图（DAG）才有拓扑排序

例如：![img](https://s2.loli.net/2024/06/14/mEZPiT2Lkn9NtBQ.png)

何写出它的拓扑排序呢？这里说一种比较常用的方法：

1. 从 DAG 图中选择一个没有前驱（即入度为0）的顶点并输出。
2. 从图中删除该顶点和所有以它为起点的有向边。
3. 重复 1 和 2 直到当前的 DAG 图为空或**当前图中不存在无前驱的顶点为止**。后一种情况说明有向图中必然存在环。

![img](https://s2.loli.net/2024/06/14/JkEI5jwrsmaCDKg.png)

于是，得到拓扑排序后的结果是 { 1, 2, 4, 3, 5 }

通常，一个有向无环图可以有**一个或多个**拓扑排序序列。



![image-20240614215731159](https://s2.loli.net/2024/06/14/BYCgrQLp5uh1IJK.png)

这道题就是检测有向图是否存在环

把所有的路都走一遍，如果又走到原来的地方说明这个是有环的



入度、出度

本题中入度如果为0代表这个课没有先修的课程



这道题先统计每个课程的前序课程是什么，然后统计一下每个课程的入度

再分情况讨论：首先入度为0的课程就是最先上的课，可以立即学习，然后再通过这些课继续后续课程

​			然后使用队列进行拓扑排序，

循环每次从队列的前端取出一个课程 `u`，处理它，然后检查它的所有后继课程 `v`。如果某后继课程 `v` 的入度在移除课程 `u` 后变为 0，这意味着课程 `v` 的所有先决条件都已满足，因此将课程 `v` 加入到队列 `q` 中以便在接下来的迭代中处理。			

# 题解

```go
func canFinish(numCourses int, prerequisites [][]int) bool {
	edge := make([][]int, numCourses)
	indeg := make([]int, numCourses) // 储存每门课程的入度
	result := make([]int, 0)
	for _, info := range prerequisites {
		edge[info[1]] = append(edge[info[1]], info[0]) // 为了学习课程 info[0]，必须先完成课程 info[1]
		indeg[info[0]]++                               // 每当课程info[0]被添加为某个课程的后续课程时，它的入度增加 1
	}

	// 入度为 0 的课程
	q := []int{}
	for i := 0; i < numCourses; i++ {
		if indeg[i] == 0 {
			q = append(q, i)
		}
	}

	for len(q) > 0 {
		u := q[0]
		q = q[1:]
		result = append(result, u)
		for _, v := range edge[u] { // 遍历课程 u 的所有后继课程 v
			indeg[v]--
			if indeg[v] == 0 {
				q = append(q, v)
			}
		}
	}
	return len(result) == numCourses
}
```

### `q`（队列）的作用：

- **队列 `q`** 主要用于存储所有入度为 0 的课程，即那些没有任何未满足先决条件的课程，可以立即开始学习的课程。
- 在算法执行过程中，`q` 动态更新，每当课程的入度变为 0（即所有依赖的课程已被处理），该课程就被添加到队列中。

### `result`（结果列表）的作用：

- **结果列表 `result`** 用于记录按照拓扑排序顺序处理的课程编号，即这些课程的先决条件已完全满足，已经可以被认为是完成的。
- 随着算法的进行，每从队列 `q` 中取出一个课程，就将其添加到 `result` 中，表示这个课程已经排序。
